# подробно о множествах https://python-scripts.com/sets
# кратко об операциях с множествами https://pythonworld.ru/tipy-dannyx-v-python/mnozhestva-set-i-frozenset.html
# еще кое-что https://habr.com/ru/post/516858/


print(type({1, 2, 3, 4, 5, 6}))
# <class 'set'>
print(type({1: 2, 3: 4, 5: 6}))
# <class 'dict'>

_dict = {}  # так лучше не писать, потому что не понятно, что это множество или словарь:
print(type(_dict))  # определило как словарь
# <class 'dict'> 
# поэтому лучше так, чтобы было видно:
_dict = dict()
print(type(_dict))
# <class 'dict'>
_set = set()
print(type(_set))
# <class 'set'>

# создание множества (похожи на создание списков):
_set = {1, 2, 3, 4, 5}

_list = [1, 2, 3, 4, 5, 5, 5, 6]
_set1 = set(_list)  # функция set приводит список к множеству
print(_set1)
# {1, 2, 3, 4, 5, 6}  # выводит только уникальные элементы

k = {i ** 2 for i in range(5)}  # создание с помощью генератора множеств
print(k)
# {0, 1, 4, 9, 16}

_list = [1, 2, 3, 4, 5, 5, 5, 6]
m = {i ** 2 for i in _list}  # при создании множества с помощью генератора множеств выводит только уникальные элементы
print(m)
# {1, 4, 36, 9, 16, 25}  # 25 вывело только один раз, хотя 5 в списке 3шт.

print(_set[1])  # множества нельзя брать по индексу и срезу, т.к. множества не упорядочены
# TypeError

_set = {1, 4, 36, 9, 16, 25}
print(len(_set))  # количество элементов в множестве
# 6
print(all(_set))  # функция all() возвращает True, если все элементы в итерируемом типе являются истинными
# True
print(any(_set))  # функция any() возвращает значение True, если хотя бы один элемент во всём итерируемом типе истинный
# True
_set = {1, 4, 36, 9, 16, 25}
_set2 = sorted(_set)
print(_set2)
# [1, 4, 9, 16, 25, 36]
print(sum(_set))
# 91
print(max(_set))
# 36
print(min(_set))
# 1

print(1 in _set)  # проверка вхождения в множество
# True
print('asd' in _set)
# False


from copy import copy, deepcopy
set_1 = set([45, 4, 2, 76, -2, 0])
set_2 = set_1
print(set_1)
# {0, 2, 4, 76, 45, -2}
print(set_2)  # действуют такие же правила, как и ранее
# {0, 2, 4, 76, 45, -2}
set_2.add(9)
print(set_1)  # при добавлении элемента 9 в set_2, он добавился и в set_1
# {0, 2, 4, 9, 76, 45, -2}
# проверяем id двух элементов, чтобы убедится что при добавлении 9 в set_2 => set_2 = set_1:
print(id(set_1))
# 1712605037728
print(id(set_2))
# 1712605037728

# если делать все через метода copy(), то при добавлении 9 в set_2 => 9 добавится только в set_2
# проверяем:
set_1 = set([45, 4, 2, 76, -2, 0])
set_2 = set_1.copy()
print(set_1)
# {0, 2, 4, 76, 45, -2}
print(set_2)
# {0, 2, 4, 76, 45, -2}
set_2.add(9)
print(set_1)
# {0, 2, 4, 76, 45, -2}
print(set_2)
# {0, 2, 4, 9, 76, 45, -2}
print(id(set_1))
# 1712605037952
print(id(set_2))
# 1712605039072

# использование deepcopy будет выдавать такой же результат как и copy() ↑↑


# по множествам можно итерироваться:
_set = {1, 2, 3, 4, 5}
for i in _set:
    print(i)
# 1
# 2
# 3
# 4
# 5
for i, v in enumerate(_set):  # использовать не актуально, т.к. множество не поддерживает индексы
    print(i, v)
# 0 1
# 1 2
# 2 3
# 3 4
# 4 5


# Методы множеств:   ↓ ↓ ↓

_set_2 = {1, 2, 3, 4, 5}
a = _set_2.add(123)  # нельзя присвоить переменную функции add
print(a)
# None
print(type(a))  # проверяем тип
# <class 'NoneType'>
_set_2.add(123)
print(_set_2)  # вывели результат с добавленным значением 123
# {1, 2, 3, 4, 5, 123}

_set_2.clear()  # очищает список
print(_set_2)
# set()
# a = _set_2.clear()  # тоже нельзя присваивать переменную
# print(type(a))
# <class 'NoneType'>


set_1 = {1, 2, 3, 4}
set_2 = {3, 4, 5, 6}
set_3 = set_1.intersection(set_2)  # выводит пересекающиеся элементы, создавая при этом новое множество
print(set_3)
# {3, 4}
set_1.intersection_update(set_2)  # выводит пересекающиеся элементы, внося при этом изменения в set_1
print(set_1)
# # {3, 4}

set_1 = {1, 2, 3, 4}
set_2 = {3, 4, 5, 6}
print(set_1.isdisjoint(set_2))  # вернет False, т.к. элементы множеств пересекаются между set_1 и set_2 => 3, 4
# False
set_1 = {1, 2}
set_2 = {3, 4, 5, 6}
print(set_1.isdisjoint(set_2))  # вернет True, т.к. элементы множеств никак не пересекаются между set_1 и set_2
# True

set_1 = {1, 2}
set_3 = {1, 2, 3, 4}
print(set_1.issubset(set_3))  # Метод sets.issubset() позволяет проверить находится ли каждый элемент множества set_1 в последовательности set_3.
# True
set_2 = {3, 4, 5, 6}
print(set_2.issubset(set_3))
# False
# метод возвращает True, если множество set_1(set_2) является подмножеством итерируемого объекта set_3, если нет, то вернет False

print(set_3.issuperset(set_1))  # Метод sets.issuperset() позволяет проверить находится ли каждый элемент последовательности set_1 в множестве set_3
# True
# Метод возвращает True, если множество set_3 является надмножеством итерируемого объекта set_1, если нет, то вернет False
print(set_1.issuperset(set_3))  #
# False

set_1 = {1, 2}  # удаляет один случайный элемент
a = set_1.pop()  # если присвоить переменную, то при выводе переменной на экран => выведет удаленный элемент множества
print(a)
# 1
print(set_1)  # вернули set_1 для проверки результата после использования функции .pop()
# {2}
a = set_1.pop()  # вызовем функцию .pop() еще раз
print(a)  # удалили последний элемент в множестве
# 2
print(set_1)  # поэтому вызовет ошибку, т.к. удалили все элементы
# TypeError

set_2 = {3, 4, 5, 6}
set_2.remove(3)  # Позволяет удалять конкретный элемент множества, возвращает set_2 без элемента 3
# {4, 5, 6}
set_2.remove(7)  # если попытаться удалить несуществующий элемент, то вызовет ошибку
# KeyError

set_3 = {1, 2, 3, 5, 6}
set_3.discard(6)  # удаляет элемент, если он находится в множестве => возвращает set_3 без 6
print(set_3)
# {1, 2, 3, 5}
set_3.discard(7)  # если элемента нет в set_3, не вызывает Error => возвращает set_3 без изменений
print(set_3)
# {1, 2, 3, 5, 6}

set_2 = {4, 5, 6}
set_3 = {1, 2, 3, 4}
set_4 = set_3.symmetric_difference(set_2)  # возвращает элементы только уникальные элементы в новое множество => не уникальные элементы удалит
print(set_4)  # вошли все элементы из множеств set_2 и set_3, кроме элемента 4
# {1, 2, 3, 5, 6}
set_3.symmetric_difference_update(set_2)  # возвращает элементы только уникальные элементы, внося измения set_3 => не уникальные элементы удалит
print(set_3)
# {1, 2, 3, 5, 6}

set_2 = {4, 5, 6}
set_3 = {1, 2, 3, 5, 6}
set_4 = set_2.union(set_3)
print(set_4)  # объединение двух множеств set_2 и set_3 в один set_4 => повторяющиеся элементы удаляются
# {1, 2, 3, 4, 5, 6}
set_2.update(set_3)  # добавит в set_2 все элементы из set_3 => повторяющиеся элементы удаляются
print(set_2)
# {1, 2, 3, 4, 5, 6}


# вариант применения функции set:
_list = [1, 1, 2, 2, 3, 4, 5, 6, 6]  # есть список с повторяющимися элементами
_list = list(set(_list))  # с помощью функции set удаляем все повторы и функцией list возвращаем список _list без повторов
print(_list)
# [1, 2, 3, 4, 5, 6]


fr = frozenset([1, 2, 3, 4, 5, 6, 6, 6, 6])  # frozenset обладает почти всеми методами set, но он не изменяемый.
print(type(fr))  # это отдельный класс
# <class 'frozenset'>
# нельзя вносить изменения методами add, update и т.д. ↑ ↑ ↑


# С множествами можно выполнять множество операций: находить объединение, пересечение... ↓↓↓↓↓↓↓↓
#
# len(s) - число элементов в множестве (размер множества).
# x in s - принадлежит ли x множеству s.
# set.isdisjoint(other) - истина, если set и other не имеют общих элементов.
# set == other - все элементы set принадлежат other, все элементы other принадлежат set.
# set.issubset(other) или set <= other - все элементы set принадлежат other.
# set.issuperset(other) или set >= other - аналогично.
# set.union(other, ...) или set | other | ... - объединение нескольких множеств.
# set.intersection(other, ...) или set & other & ... - пересечение.
# set.difference(other, ...) или set - other - ... - множество из всех элементов set, не принадлежащие ни одному из other.
# set.symmetric_difference(other); set ^ other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
# set.copy() - копия множества.
#
# И операции, непосредственно изменяющие множество: ↓↓↓↓↓↓↓↓
#
# set.update(other, ...); set |= other | ... - объединение.
# set.intersection_update(other, ...); set &= other & ... - пересечение.
# set.difference_update(other, ...); set -= other | ... - вычитание.
# set.symmetric_difference_update(other); set ^= other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
# set.add(elem) - добавляет элемент в множество.
# set.remove(elem) - удаляет элемент из множества. KeyError, если такого элемента не существует.
# set.discard(elem) - удаляет элемент, если он находится в множестве.
# set.pop() - удаляет первый элемент из множества. Так как множества не упорядочены, нельзя точно сказать, какой элемент будет первым.
# set.clear() - очистка множества.


